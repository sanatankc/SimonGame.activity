// Frame lag-fix constants
export var FRAME_MS = 50 / 3;
export var TOO_LONG_FRAME_MS = 250;
export var CHAINED_TWEENS = '_chainedTweens';
// Event System
export var EVENT_CALLBACK = 'Callback';
export var EVENT_UPDATE = 'update';
export var EVENT_COMPLETE = 'complete';
export var EVENT_START = 'start';
export var EVENT_REPEAT = 'repeat';
export var EVENT_REVERSE = 'reverse';
export var EVENT_PAUSE = 'pause';
export var EVENT_PLAY = 'play';
export var EVENT_RESTART = 'restart';
export var EVENT_STOP = 'stop';
export var EVENT_SEEK = 'seek';
// For String tweening stuffs
export var STRING_PROP = 'STRING_PROP';
// Also RegExp's for string tweening
export var NUM_REGEX = /\s+|([A-Za-z?().,{}:""[\]#\%]+)|([-+]=+)?([-+]+)?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]=?\d+)?/g;
export var HEXC_REGEX = /^#([0-9a-f]{6}|[0-9a-f]{3})$/i;
// Copies everything, duplicates, no shallow-copy
export function deepCopy(source) {
    if ((source && source.nodeType) || source === undefined || typeof source !== 'object') {
        return source;
    }
    else if (Array.isArray(source)) {
        return [].concat(source);
    }
    else if (typeof source === 'object') {
        var target = {};
        for (var prop in source) {
            target[prop] = deepCopy(source[prop]);
        }
        return target;
    }
    return source;
}
var isNaNForST = function (v) {
    return isNaN(+v) || ((v[0] === '+' || v[0] === '-') && v[1] === '=') || v === '' || v === ' ';
};
var hexColor = /^#([0-9a-f]{6}|[0-9a-f]{3})$/i;
var hex2rgb = function (all, hex) {
    var r;
    var g;
    var b;
    if (hex.length === 3) {
        r = hex[0];
        g = hex[1];
        b = hex[2];
        hex = r + r + g + g + b + b;
    }
    var color = parseInt(hex, 16);
    r = color >> 16 & 255;
    g = color >> 8 & 255;
    b = color & 255;
    return "rgb(" + r + "," + g + "," + b + ")";
};
export function decomposeString(fromValue) {
    return typeof fromValue !== 'string' ? fromValue : fromValue.replace(hexColor, hex2rgb).match(NUM_REGEX).map(function (v) { return (isNaNForST(v) ? v : +v); });
}
// Decompose value, now for only `string` that required
export function decompose(prop, obj, from, to, stringBuffer) {
    var fromValue = from[prop];
    var toValue = to[prop];
    if (typeof fromValue === 'string' || typeof toValue === 'string') {
        var fromValue1 = Array.isArray(fromValue) && fromValue[0] === STRING_PROP ? fromValue : decomposeString(fromValue);
        var toValue1 = Array.isArray(toValue) && toValue[0] === STRING_PROP ? toValue : decomposeString(toValue);
        var i = 1;
        while (i < fromValue1.length) {
            if (fromValue1[i] === toValue1[i] && typeof fromValue1[i - 1] === 'string') {
                fromValue1.splice(i - 1, 2, fromValue1[i - 1] + fromValue1[i]);
                toValue1.splice(i - 1, 2, toValue1[i - 1] + toValue1[i]);
            }
            else {
                i++;
            }
        }
        i = 0;
        if (fromValue1[0] === STRING_PROP) {
            fromValue1.shift();
        }
        if (toValue1[0] === STRING_PROP) {
            toValue1.shift();
        }
        var fromValue2 = { isString: true, length: fromValue1.length };
        var toValue2 = { isString: true, length: toValue1.length };
        while (i < fromValue2.length) {
            fromValue2[i] = fromValue1[i];
            toValue2[i] = toValue1[i];
            i++;
        }
        from[prop] = fromValue2;
        to[prop] = toValue2;
        return true;
    }
    else if (typeof fromValue === 'object' && typeof toValue === 'object') {
        if (Array.isArray(fromValue)) {
            return fromValue.map(function (v, i) {
                return decompose(i, obj[prop], fromValue, toValue);
            });
        }
        else {
            for (var prop2 in toValue) {
                decompose(prop2, obj[prop], fromValue, toValue);
            }
        }
        return true;
    }
    return false;
}
// Recompose value
export var DECIMAL = Math.pow(10, 4);
export var RGB = 'rgb(';
export var RGBA = 'rgba(';
export var isRGBColor = function (v, i, r) {
    if (r === void 0) { r = RGB; }
    return typeof v[i] === 'number' &&
        (v[i - 1] === r || v[i - 3] === r || v[i - 5] === r);
};
export function recompose(prop, obj, from, to, t, originalT, stringBuffer) {
    var fromValue = stringBuffer ? from : from[prop];
    var toValue = stringBuffer ? to : to[prop];
    if (toValue === undefined) {
        return fromValue;
    }
    if (fromValue === undefined ||
        typeof fromValue === 'string' ||
        fromValue === toValue) {
        return toValue;
    }
    else if (typeof fromValue === 'object' && typeof toValue === 'object') {
        if (!fromValue || !toValue) {
            return obj[prop];
        }
        if (typeof fromValue === 'object' && !!fromValue && fromValue.isString) {
            var STRING_BUFFER = '';
            for (var i = 0, len = fromValue.length; i < len; i++) {
                var isRelative = typeof fromValue[i] === 'number' && typeof toValue[i] === 'string' && toValue[i][1] === '=';
                var currentValue = typeof fromValue[i] !== 'number'
                    ? fromValue[i]
                    : (((isRelative
                        ? fromValue[i] +
                            parseFloat(toValue[i][0] + toValue[i].substr(2)) * t
                        : fromValue[i] + (toValue[i] - fromValue[i]) * t) *
                        DECIMAL) |
                        0) /
                        DECIMAL;
                if (isRGBColor(fromValue, i) || isRGBColor(fromValue, i, RGBA)) {
                    currentValue |= 0;
                }
                STRING_BUFFER += currentValue;
                if (isRelative && originalT === 1) {
                    fromValue[i] =
                        fromValue[i] +
                            parseFloat(toValue[i][0] + toValue[i].substr(2));
                }
            }
            if (!stringBuffer) {
                obj[prop] = STRING_BUFFER;
            }
            return STRING_BUFFER;
        }
        else if (Array.isArray(fromValue) && fromValue[0] !== STRING_PROP) {
            for (var i = 0, len = fromValue.length; i < len; i++) {
                if (fromValue[i] === toValue[i]) {
                    continue;
                }
                recompose(i, obj[prop], fromValue, toValue, t, originalT);
            }
        }
        else if (typeof fromValue === 'object' && !!fromValue && !fromValue.isString) {
            for (var i in fromValue) {
                if (fromValue[i] === toValue[i]) {
                    continue;
                }
                recompose(i, obj[prop], fromValue, toValue, t, originalT);
            }
        }
    }
    else if (typeof fromValue === 'number') {
        var isRelative = typeof toValue === 'string';
        obj[prop] =
            (((isRelative
                ? fromValue + parseFloat(toValue[0] + toValue.substr(2)) * t
                : fromValue + (toValue - fromValue) * t) *
                DECIMAL) |
                0) /
                DECIMAL;
        if (isRelative && originalT === 1) {
            from[prop] = obj[prop];
        }
    }
    else if (typeof toValue === 'function') {
        obj[prop] = toValue(t);
    }
    return obj[prop];
}
// Dot notation => Object structure converter
// example
// {'scale.x.y.z':'VALUE'} => {scale:{x:{y:{z:'VALUE'}}}}
// Only works for 3-level parsing, after 3-level, parsing dot-notation not works as it's not affects
var propRegExp = /([.\[])/g;
var replaceBrace = /\]/g;
var propExtract = function (obj, property) {
    var value = obj[property];
    var props = property.replace(replaceBrace, '').split(propRegExp);
    var propsLastIndex = props.length - 1;
    var lastArr = Array.isArray(obj);
    var lastObj = typeof obj === 'object' && !lastArr;
    if (lastObj) {
        obj[property] = null;
        delete obj[property];
    }
    else if (lastArr) {
        obj.splice(property, 1);
    }
    return props.reduce(function (nested, prop, index) {
        if (lastArr) {
            if (prop !== '.' && prop !== '[') {
                prop *= 1;
            }
        }
        var nextProp = props[index + 1];
        var nextIsArray = nextProp === '[';
        if (prop === '.' || prop === '[') {
            if (prop === '.') {
                lastObj = true;
                lastArr = false;
            }
            else if (prop === '[') {
                lastObj = false;
                lastArr = true;
            }
            return nested;
        }
        else if (nested[prop] === undefined) {
            if (lastArr || lastObj) {
                nested[prop] =
                    index === propsLastIndex
                        ? value
                        : lastArr || nextIsArray ? [] : lastObj ? {} : null;
                lastObj = lastArr = false;
                return nested[prop];
            }
        }
        else if (nested[prop] !== undefined) {
            if (index === propsLastIndex) {
                nested[prop] = value;
            }
            return nested[prop];
        }
        return nested;
    }, obj);
};
export var SET_NESTED = function (nested) {
    if (typeof nested === 'object' && !!nested) {
        for (var prop in nested) {
            if (prop.indexOf('.') !== -1 || prop.indexOf('[') !== -1) {
                propExtract(nested, prop);
            }
            else if (typeof nested[prop] === 'object' && !!nested[prop]) {
                var nested2 = nested[prop];
                for (var prop2 in nested2) {
                    if (prop2.indexOf('.') !== -1 || prop2.indexOf('[') !== -1) {
                        propExtract(nested2, prop2);
                    }
                    else if (typeof nested2[prop2] === 'object' && !!nested2[prop2]) {
                        var nested3 = nested2[prop2];
                        for (var prop3 in nested3) {
                            if (prop3.indexOf('.') !== -1 || prop3.indexOf('[') !== -1) {
                                propExtract(nested3, prop3);
                            }
                        }
                    }
                }
            }
        }
    }
    return nested;
};
